CCS PCD C Compiler, Version 4.114, 93460303               15-jul-15 15:17

               Filename: C:\Users\Renato\Documents\TCC\ADC\ADC.lst

               ROM used: 4416 bytes (5%)
                         Largest free fragment is 61120
               RAM used: 188 (1%) at main() level
                         194 (1%) worst case
               Stack:    3 worst case (1 in main + 2 for interrupts)

*
00000:  GOTO    10B4
*
0001A:  DATA    8E,05,00
*
0003A:  DATA    48,07,00
.................... #include <ADC.h> 
.................... #include <33FJ128MC802.h> 
.................... //////// Standard Header file for the DSPIC33FJ128MC802 device //////////////// 
.................... #device DSPIC33FJ128MC802 
.................... #list 
....................  
.................... #device ADC=10 
.................... #FUSES NOWDT, NOWRTB, NOBSS, NORBS, NOWRTSS, NOSSS, NORSS, NOWRTSS, NOPROTECT, IESO, 
.................... #FUSES NOPR, PR_PLL, XT, IOL1WAY, CKSFSM, WPOSTS16, WPRES128, WINDIS, PUT128, LPOL_HIGH, HPOL_HIGH, NOPWMPIN, ICSP1, NOJTAG, NODEBUG 
.................... #use delay(clock=80000000) 
....................  
.................... #WORD CLKDIV = 0x0744   //PLLPOST(6,7) - PLLPRE(0,1,2,3,4) 
.................... #BIT PLLPOST_1 = CLKDIV.6 
.................... #BIT PLLPOST_2 = CLKDIV.7 
.................... #BIT PLLPRE_1 = CLKDIV.0 
.................... #BIT PLLPRE_2 = CLKDIV.1 
.................... #BIT PLLPRE_3 = CLKDIV.2 
.................... #BIT PLLPRE_4 = CLKDIV.3 
.................... #BIT PLLPRE_5 = CLKDIV.4 
.................... #WORD PLLFBD = 0x0746   //PLLDIV(0,1,2,3,4,5,6,7,8) 
.................... #BIT PLLDIV_1 = PLLFBD.0 
.................... #BIT PLLDIV_2 = PLLFBD.1 
.................... #BIT PLLDIV_3 = PLLFBD.2 
.................... #BIT PLLDIV_4 = PLLFBD.3 
.................... #BIT PLLDIV_5 = PLLFBD.4 
.................... #BIT PLLDIV_6 = PLLFBD.5 
.................... #BIT PLLDIV_7 = PLLFBD.6 
.................... #BIT PLLDIV_8 = PLLFBD.7 
.................... #BIT PLLDIV_9 = PLLFBD.8 
....................  
.................... #WORD CNEN1 = 0x0060 
.................... #BIT CN2 = CNEN1.2 
.................... #BIT CN3 = CNEN1.3 
.................... #BIT CN4 = CNEN1.4 
....................  
.................... #WORD IFS1 = 0x0086 
.................... #BIT CNIF = IFS1.3 
....................  
.................... #WORD IEC1 = 0x0096 
.................... #BIT CNIE = IEC1.3 
....................  
.................... #WORD PORTA = 0x02C2 
.................... #WORD PORTB = 0x02CA 
....................  
.................... #define OFF 0x0000 
.................... #define PH1 0x10 
.................... #define PL1 0x01 
.................... #define PH2 0x20 
.................... #define PL2 0x02 
.................... #define PH3 0x30 
.................... #define PL3 0x03; 
.................... #define CH1 0x4000 
.................... #define CL1 0x8000 
.................... #define CH2 0x1000 
.................... #define CL2 0x2000 
.................... #define CH3 0x0400 
.................... #define CL3 0x0800 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #pin_select U1TX = PIN_B9 
.................... #pin_select U1RX = PIN_B8 
.................... #use rs232(UART1,stream = ccm, baud=115200,parity=N,xmit=PIN_B9,rcv=PIN_B8,bits=8, stop=1)  
....................  
....................  
....................  
.................... #word OVDCON=getenv("SFR:OVDCON") 
.................... #word TRISB=getenv("SFR:TRISB") 
....................  
.................... void zera_pwm(); 
.................... int duty = 0; 
....................  
.................... //VARIAVEIS METODO 1 
.................... //unsigned long int unaux=0; 
.................... //float Tensao=0, Vel=0; 
.................... float un=0.0, un1=0.0, un2=0.0, en=0.0, en1=0.0, en2=0.0; 
.................... int Referencia = 140, H, led; 
.................... float ref = Referencia*95/248, Digital, unaux, Digital1; 
.................... int count=0, value=0, flagcount = 0, oi=40, i, running_motor =0; 
....................  
....................  
.................... //VARIAVEIS METODO 2 
.................... //float vetor_velocidade[1001], VelRAD; 
.................... //int running_motor = 0, contador = 0, i=0; 
....................  
....................  
.................... /////////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #INT_TIMER1 Level=7 
.................... void TIMER_isr() 
.................... { 
0058E:  PUSH    42
00590:  PUSH    36
00592:  MOV     W0,[W15++]
00594:  MOV     #2,W0
00596:  REPEAT  #C
00598:  MOV     [W0++],[W15++]
....................    disable_interrupts(INT_TIMER1); 
0059A:  BCLR.B  94.3
....................    clear_interrupt(INT_TIMER1); 
0059C:  BCLR.B  84.3
....................     
....................  
....................    /*VelRAD = contador*628.31853/3; //Nmero de pulsos contados *1000*2*pi/300 para 1ms 
....................    //VelRAD = contador*62.831853/3; //Nmero de pulsos contados*100*2*pi/300 para 10ms 
....................     
....................    //OBTENO DA RESPOSTA AO DEGRAU 
....................     
....................    if(running_motor==1) //SE O MOTOR ESTIVER COMEADO A GIRAR 
....................    { 
....................       if(i<1001) 
....................       { 
....................          vetor_velocidade[i] = VelRAD;  //CADA VALOR OBTIDO EM CADA MS VAI PRA UMA POSIO DO VETOR 
....................          VelRAD = 0; 
....................          i++; 
....................       }  
....................       contador = 0; //RESETA O CONTADOR 
....................    }*/ 
....................     
.................... /////////////////////////////////////////////////////////////////////////////////// 
....................     
....................    //TESTE TROCA DE DUTY EM X VEZES A VELOCIDADE DE INTERRUPO DO TIMER 
....................    /*if(count==0 && flagcount ==0) 
....................    { 
....................      duty = 4000; 
....................      flagcount = 1; 
....................      count =30; 
....................      output_high(pin_b4); 
....................    
....................    } 
....................      
....................    if(count==0 && flagcount ==1) 
....................    { 
....................      duty = 8000; 
....................      flagcount = 0; 
....................      count = 30; 
....................      output_low(pin_b4); 
....................    } 
....................    else 
....................    { 
....................    count--; 
....................    }*/ 
....................     
....................   
....................    //TESTE TROCA DE DUTY CYCLE NA VELOCIDADE DA INTERRUPO DO TIMER 
....................    /*if(led==0) 
....................    { 
....................       output_high(pin_b4); 
....................       led=1; 
....................       duty =4000; 
....................    }else{ 
....................    output_low(pin_b4); 
....................    led=0; 
....................    duty=8000; 
....................    }*/ 
....................    /*Digital = 0; 
....................    Digital1 = 0; 
....................    //CONTAS DO ADC PARA CONTROLE 
....................    for(i=0;i<49;i++) 
....................    { 
....................    Digital = read_adc(); 
....................    Digital1 = Digital1 + Digital; 
....................    }*/ 
....................    if(running_motor==1) 
0059E:  MOV     83A,W4
005A0:  CP      W4,#1
005A2:  BRA     NZ,698
....................    { 
....................   //  
....................    if(oi==0) 
005A4:  CP0     836
005A6:  BRA     NZ,5B2
....................    { 
....................       ref = 230*95/248; 
005A8:  CLR     820
005AA:  MOV     #42B0,W4
005AC:  MOV     W4,822
....................    }else 
005AE:  GOTO    5B4
....................    {    
....................    oi--; 
005B2:  DEC     0836
....................    } 
....................     
....................    Digital = read_adc(); 
005B4:  BCLR.B  320.0
005B6:  BSET.B  320.1
005B8:  BTSS.B  320.0
005BA:  BRA     5B8
005BC:  MOV     300,W0
005BE:  CALL    212
005C2:  MOV     W0,824
005C4:  MOV     W1,826
....................    //Tensao = Digital*0.003193359; 
....................    //H = 50*Digital*0.003193359; 
....................    H = Digital*0.12038; 
005C6:  MOV     824,W0
005C8:  MOV     826,W1
005CA:  MOV     #89CA,W2
005CC:  MOV     #3DF6,W3
005CE:  CALL    24C
005D2:  CALL    310
005D6:  MOV     W0,81C
....................     
....................     
....................     
....................    //CONTROLADOR 
....................    en = ref-H; 
005D8:  MOV     81C,W0
005DA:  CALL    33C
005DE:  BSET.B  43.0
005E0:  MOV     W0,W2
005E2:  MOV     W1,W3
005E4:  MOV     820,W0
005E6:  MOV     822,W1
005E8:  CALL    386
005EC:  MOV     W0,80E
005EE:  MOV     W1,810
....................    //en = ref-read_adc()*0.097751; 
....................    //un = en*0.009362 - en1*0.01827 + en2*0.008916 + un1*1.931 - un2*0.931;   //1ms 
....................    //un = en*0.005237 - en1*0.01012 + en2*0.004888 + un1*1.905 - un2*0.9048;  //1ms_2 
....................    //un = en*0.008865 - en1*0.00414 + en2*0.0005839 + un1*0.7179 + un2*0.2821;  //50ms 
....................    if(en==0) 
005F0:  MOV     80E,W0
005F2:  MOV     810,W1
005F4:  MOV     #0,W2
005F6:  MOV     #0,W3
005F8:  CALL    526
005FC:  BRA     NZ,606
....................    { 
....................       en=0.000001; 
005FE:  MOV     #37BD,W4
00600:  MOV     W4,80E
00602:  MOV     #3586,W4
00604:  MOV     W4,810
....................    } 
....................    //un = 0.004824*en - 0.004771*en1 + un1; //1ms_3 
....................    //un = 0.005064*en - 0.004531*en1 + un1; //10ms_3 
....................    //un = 0.00613*en - 0.003465*en1 + un1; //50ms_3 
....................    //un = 0.007463*en - 0.002132*en1 + un1; //100ms_3 
....................    //un = 0.009699*en - 0.009638*en1 + un1; //1ms_corrigido 
....................    un = 0.01118*en - 0.008158*en1 + un1; //50ms_corrigido 
00606:  MOV     #2C52,W0
00608:  MOV     #3C37,W1
0060A:  MOV     80E,W2
0060C:  MOV     810,W3
0060E:  CALL    24C
00612:  MOV     W0,W5
00614:  MOV     W1,W6
00616:  MOV     #A922,W0
00618:  MOV     #3C05,W1
0061A:  MOV     812,W2
0061C:  MOV     814,W3
0061E:  CALL    24C
00622:  BSET.B  43.0
00624:  MOV     W0,W2
00626:  MOV     W1,W3
00628:  MOV     W5,W0
0062A:  MOV     W6,W1
0062C:  CALL    386
00630:  MOV     W0,W5
00632:  MOV     W1,W6
00634:  BCLR.B  43.0
00636:  MOV     W5,W0
00638:  MOV     W6,W1
0063A:  MOV     806,W2
0063C:  MOV     808,W3
0063E:  CALL    386
00642:  MOV     W0,802
00644:  MOV     W1,804
....................   // en2 = en1; 
....................    en1 = en; 
00646:  PUSH    80E
00648:  POP     812
0064A:  PUSH    810
0064C:  POP     814
....................   // un2 = un1; 
....................    un1 = un; 
0064E:  PUSH    802
00650:  POP     806
00652:  PUSH    804
00654:  POP     808
....................     
....................    //TESTE CONTROLE ON-OFF EM TORNO DE UM SET POINT 
....................    /*if(en>0) 
....................    { 
....................       duty = 8000; 
....................    } 
....................    else 
....................    { 
....................       duty = 4000; 
....................    }*/ 
....................     
....................    //ATRIBUI UN AO DUTY 
....................    un = un*10000; 
00656:  MOV     802,W0
00658:  MOV     804,W1
0065A:  MOV     #4000,W2
0065C:  MOV     #461C,W3
0065E:  CALL    24C
00662:  MOV     W0,802
00664:  MOV     W1,804
....................     
....................    if(un>9500) 
00666:  MOV     #7000,W0
00668:  MOV     #4614,W1
0066A:  MOV     802,W2
0066C:  MOV     804,W3
0066E:  CALL    526
00672:  BRA     NC,67C
....................    { 
....................      //unaux = 9500; 
....................      un = 9500; 
00674:  MOV     #7000,W4
00676:  MOV     W4,802
00678:  MOV     #4614,W4
0067A:  MOV     W4,804
....................    } 
....................    if(un<0) 
0067C:  MOV     802,W0
0067E:  MOV     804,W1
00680:  MOV     #0,W2
00682:  MOV     #0,W3
00684:  CALL    526
00688:  BRA     NC,68E
....................    { 
....................       un = 0; 
0068A:  CLR     802
0068C:  CLR     804
....................    } 
....................     
....................     
....................    duty = (unsigned int)un; 
0068E:  MOV     802,W0
00690:  MOV     804,W1
00692:  CALL    310
00696:  MOV     W0,800
....................    } 
....................    //VALORES ENVIADOS PELA SERIAL PARA TESTE 
....................     
....................    /*   if(oi!=0) 
....................    { 
....................       printf(" %f," en); 
....................       oi--; 
....................    }*/ 
....................    /*if(oi!=0){ 
....................    printf("\n\r\n\rDUTY: "); 
....................      printf("%Lu", duty); 
....................      printf("\n\r\n\rADC: "); 
....................      printf("\n\r %f", Digital); 
....................      printf("\n\r\n\rERRO: "); 
....................      printf("%f", en); 
....................      printf("\n\r\n\rUN: "); 
....................      printf(" %f \n\r\n\r", un); 
....................      oi--; 
....................    }*/ 
....................      enable_interrupts(INT_TIMER1); 
00698:  BSET.B  94.3
....................    } 
....................  
0069A:  BCLR.B  84.3
0069C:  MOV     #1A,W0
0069E:  REPEAT  #C
006A0:  MOV     [--W15],[W0--]
006A2:  MOV     [--W15],W0
006A4:  POP     36
006A6:  POP     42
006A8:  RETFIE  
.................... #INT_CNI 
.................... void CNI_isr()                //CN INTERRUPT SERVICE ROUTINE 
.................... { 
*
00748:  PUSH    42
0074A:  PUSH    36
0074C:  MOV     W0,[W15++]
0074E:  MOV     #2,W0
00750:  REPEAT  #C
00752:  MOV     [W0++],[W15++]
....................      unsigned int Hall; 
....................       
....................      //contador++; 
....................       
....................      //disable_interrupts(INT_TIMER1); 
....................      disable_interrupts(INTR_CN_PIN|PIN_B1); 
00754:  BCLR.B  C.5
....................      disable_interrupts(INTR_CN_PIN|PIN_B2); 
00756:  BCLR.B  C.6
....................      disable_interrupts(INTR_CN_PIN|PIN_B3); 
00758:  BCLR.B  C.7
....................       
....................      Hall = input_b(); 
0075A:  SETM    2C8
0075C:  PUSH    2CA
0075E:  POP     83C
....................      Hall = Hall&0x000E; 
00760:  MOV     83C,W0
00762:  AND     W0,#E,W0
00764:  MOV     W0,83C
....................      Hall = Hall>>1; 
00766:  LSR     83C
....................      //duty = 2.5*3700; 
....................      delay_us(250); 
00768:  REPEAT  #270E
0076A:  NOP     
....................       
....................      running_motor = 1; 
0076C:  MOV     #1,W4
0076E:  MOV     W4,83A
....................       
....................      //value = read_adc(); 
....................      /*printf("Valor Hall:\n"); 
....................      printf("\n %2u", duty);*/ 
....................      switch(Hall) 
....................      { 
00770:  MOV     83C,W0
00772:  XOR     #0,W0
00774:  BRA     Z,794
00776:  XOR     #1,W0
00778:  BRA     Z,79C
0077A:  XOR     #3,W0
0077C:  BRA     Z,8E8
0077E:  XOR     #1,W0
00780:  BRA     Z,A30
00782:  XOR     #7,W0
00784:  BRA     Z,B78
00786:  XOR     #1,W0
00788:  BRA     Z,CC0
0078A:  XOR     #3,W0
0078C:  BRA     Z,E08
0078E:  XOR     #1,W0
00790:  BRA     Z,F50
00792:  BRA     F58
....................                  case(0x0000): 
....................                               zera_pwm(); 
00794:  CALL    6AA
....................                               break; 
00798:  GOTO    F58
....................                  case(0x0001): 
....................                               set_motor_unit(1,1,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
0079C:  MOV     #FEEE,W1
0079E:  MOV     1C8,W2
007A0:  MOV     #11,W3
007A2:  AND     W2,W1,W2
007A4:  IOR      W2,  W3,W2
007A6:  MOV     W2,1C8
007A8:  MOV     #FCFC,W1
007AA:  MOV     1D4,W2
007AC:  MOV     #0,W3
007AE:  AND     W2,W1,W2
007B0:  IOR      W2,  W3,W2
007B2:  MOV     W2,1D4
007B4:  MOV     #FCFE,W1
007B6:  MOV     1D0,W2
007B8:  MOV     #0,W3
007BA:  AND     W2,W1,W2
007BC:  IOR      W2,  W3,W2
007BE:  MOV     W2,1D0
007C0:  MOV     #FCFE,W1
007C2:  MOV     1D2,W2
007C4:  MOV     #0,W3
007C6:  AND     W2,W1,W2
007C8:  IOR      W2,  W3,W2
007CA:  MOV     W2,1D2
007CC:  MOV.B   #41,W0L
007CE:  MOV.B   W0L,1CC
007D0:  BCLR.B  1CE.1
007D2:  BCLR.B  1CE.0
....................                               set_motor_unit(1,2,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
007D4:  MOV     #FDDD,W1
007D6:  MOV     1C8,W2
007D8:  MOV     #22,W3
007DA:  AND     W2,W1,W2
007DC:  IOR      W2,  W3,W2
007DE:  MOV     W2,1C8
007E0:  MOV     #F3F3,W1
007E2:  MOV     1D4,W2
007E4:  MOV     #0,W3
007E6:  AND     W2,W1,W2
007E8:  IOR      W2,  W3,W2
007EA:  MOV     W2,1D4
007EC:  MOV     #F3FD,W1
007EE:  MOV     1D0,W2
007F0:  MOV     #0,W3
007F2:  AND     W2,W1,W2
007F4:  IOR      W2,  W3,W2
007F6:  MOV     W2,1D0
007F8:  MOV     #F3FD,W1
007FA:  MOV     1D2,W2
007FC:  MOV     #0,W3
007FE:  AND     W2,W1,W2
00800:  IOR      W2,  W3,W2
00802:  MOV     W2,1D2
00804:  BCLR.B  1CE.3
00806:  BCLR.B  1CE.2
....................                               set_motor_unit(1,3,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00808:  MOV     #FBBB,W1
0080A:  MOV     1C8,W2
0080C:  MOV     #44,W3
0080E:  AND     W2,W1,W2
00810:  IOR      W2,  W3,W2
00812:  MOV     W2,1C8
00814:  MOV     #CFCF,W1
00816:  MOV     1D4,W2
00818:  MOV     #0,W3
0081A:  AND     W2,W1,W2
0081C:  IOR      W2,  W3,W2
0081E:  MOV     W2,1D4
00820:  MOV     #CFFB,W1
00822:  MOV     1D0,W2
00824:  MOV     #0,W3
00826:  AND     W2,W1,W2
00828:  IOR      W2,  W3,W2
0082A:  MOV     W2,1D0
0082C:  MOV     #CFFB,W1
0082E:  MOV     1D2,W2
00830:  MOV     #0,W3
00832:  AND     W2,W1,W2
00834:  IOR      W2,  W3,W2
00836:  MOV     W2,1D2
00838:  BCLR.B  1CE.5
0083A:  BCLR.B  1CE.4
....................                               set_motor_pwm_duty(1,1,duty);  
0083C:  PUSH    800
0083E:  POP     1D6
....................                               set_motor_pwm_duty(1,2,duty);  
00840:  PUSH    800
00842:  POP     1D8
....................                               set_motor_pwm_duty(1,3,duty); 
00844:  PUSH    800
00846:  POP     1DA
....................                               set_motor_unit(1,1,MPWM_ENABLE,2,2); 
00848:  MOV     #FEEE,W1
0084A:  MOV     1C8,W2
0084C:  MOV     #11,W3
0084E:  AND     W2,W1,W2
00850:  IOR      W2,  W3,W2
00852:  MOV     W2,1C8
00854:  MOV     #FCFC,W1
00856:  MOV     1D4,W2
00858:  MOV     #300,W3
0085A:  AND     W2,W1,W2
0085C:  IOR      W2,  W3,W2
0085E:  MOV     W2,1D4
00860:  MOV     #FCFE,W1
00862:  MOV     1D0,W2
00864:  MOV     #0,W3
00866:  AND     W2,W1,W2
00868:  IOR      W2,  W3,W2
0086A:  MOV     W2,1D0
0086C:  MOV     #FCFE,W1
0086E:  MOV     1D2,W2
00870:  MOV     #0,W3
00872:  AND     W2,W1,W2
00874:  IOR      W2,  W3,W2
00876:  MOV     W2,1D2
00878:  BCLR.B  1CE.1
0087A:  BCLR.B  1CE.0
....................                               set_motor_unit(1,2,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
0087C:  MOV     #FDDD,W1
0087E:  MOV     1C8,W2
00880:  MOV     #22,W3
00882:  AND     W2,W1,W2
00884:  IOR      W2,  W3,W2
00886:  MOV     W2,1C8
00888:  MOV     #F3F3,W1
0088A:  MOV     1D4,W2
0088C:  MOV     #0,W3
0088E:  AND     W2,W1,W2
00890:  IOR      W2,  W3,W2
00892:  MOV     W2,1D4
00894:  MOV     #F3FD,W1
00896:  MOV     1D0,W2
00898:  MOV     #0,W3
0089A:  AND     W2,W1,W2
0089C:  IOR      W2,  W3,W2
0089E:  MOV     W2,1D0
008A0:  MOV     #F3FD,W1
008A2:  MOV     1D2,W2
008A4:  MOV     #0,W3
008A6:  AND     W2,W1,W2
008A8:  IOR      W2,  W3,W2
008AA:  MOV     W2,1D2
008AC:  BCLR.B  1CE.3
008AE:  BCLR.B  1CE.2
....................                               set_motor_unit(1,3,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_1,2,2); 
008B0:  MOV     #FBBB,W1
008B2:  MOV     1C8,W2
008B4:  MOV     #44,W3
008B6:  AND     W2,W1,W2
008B8:  IOR      W2,  W3,W2
008BA:  MOV     W2,1C8
008BC:  MOV     #CFCF,W1
008BE:  MOV     1D4,W2
008C0:  MOV     #10,W3
008C2:  AND     W2,W1,W2
008C4:  IOR      W2,  W3,W2
008C6:  MOV     W2,1D4
008C8:  MOV     #CFFB,W1
008CA:  MOV     1D0,W2
008CC:  MOV     #0,W3
008CE:  AND     W2,W1,W2
008D0:  IOR      W2,  W3,W2
008D2:  MOV     W2,1D0
008D4:  MOV     #CFFB,W1
008D6:  MOV     1D2,W2
008D8:  MOV     #0,W3
008DA:  AND     W2,W1,W2
008DC:  IOR      W2,  W3,W2
008DE:  MOV     W2,1D2
008E0:  BCLR.B  1CE.5
008E2:  BCLR.B  1CE.4
....................                              // CNIE = 1; 
....................                               break; 
008E4:  GOTO    F58
....................  
....................                  case(0x0002): 
....................                               set_motor_unit(1,1,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
008E8:  MOV     #FEEE,W1
008EA:  MOV     1C8,W2
008EC:  MOV     #11,W3
008EE:  AND     W2,W1,W2
008F0:  IOR      W2,  W3,W2
008F2:  MOV     W2,1C8
008F4:  MOV     #FCFC,W1
008F6:  MOV     1D4,W2
008F8:  MOV     #0,W3
008FA:  AND     W2,W1,W2
008FC:  IOR      W2,  W3,W2
008FE:  MOV     W2,1D4
00900:  MOV     #FCFE,W1
00902:  MOV     1D0,W2
00904:  MOV     #0,W3
00906:  AND     W2,W1,W2
00908:  IOR      W2,  W3,W2
0090A:  MOV     W2,1D0
0090C:  MOV     #FCFE,W1
0090E:  MOV     1D2,W2
00910:  MOV     #0,W3
00912:  AND     W2,W1,W2
00914:  IOR      W2,  W3,W2
00916:  MOV     W2,1D2
00918:  BCLR.B  1CE.1
0091A:  BCLR.B  1CE.0
....................                               set_motor_unit(1,2,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
0091C:  MOV     #FDDD,W1
0091E:  MOV     1C8,W2
00920:  MOV     #22,W3
00922:  AND     W2,W1,W2
00924:  IOR      W2,  W3,W2
00926:  MOV     W2,1C8
00928:  MOV     #F3F3,W1
0092A:  MOV     1D4,W2
0092C:  MOV     #0,W3
0092E:  AND     W2,W1,W2
00930:  IOR      W2,  W3,W2
00932:  MOV     W2,1D4
00934:  MOV     #F3FD,W1
00936:  MOV     1D0,W2
00938:  MOV     #0,W3
0093A:  AND     W2,W1,W2
0093C:  IOR      W2,  W3,W2
0093E:  MOV     W2,1D0
00940:  MOV     #F3FD,W1
00942:  MOV     1D2,W2
00944:  MOV     #0,W3
00946:  AND     W2,W1,W2
00948:  IOR      W2,  W3,W2
0094A:  MOV     W2,1D2
0094C:  BCLR.B  1CE.3
0094E:  BCLR.B  1CE.2
....................                               set_motor_unit(1,3,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00950:  MOV     #FBBB,W1
00952:  MOV     1C8,W2
00954:  MOV     #44,W3
00956:  AND     W2,W1,W2
00958:  IOR      W2,  W3,W2
0095A:  MOV     W2,1C8
0095C:  MOV     #CFCF,W1
0095E:  MOV     1D4,W2
00960:  MOV     #0,W3
00962:  AND     W2,W1,W2
00964:  IOR      W2,  W3,W2
00966:  MOV     W2,1D4
00968:  MOV     #CFFB,W1
0096A:  MOV     1D0,W2
0096C:  MOV     #0,W3
0096E:  AND     W2,W1,W2
00970:  IOR      W2,  W3,W2
00972:  MOV     W2,1D0
00974:  MOV     #CFFB,W1
00976:  MOV     1D2,W2
00978:  MOV     #0,W3
0097A:  AND     W2,W1,W2
0097C:  IOR      W2,  W3,W2
0097E:  MOV     W2,1D2
00980:  BCLR.B  1CE.5
00982:  BCLR.B  1CE.4
....................                               set_motor_pwm_duty(1,1,duty);  
00984:  PUSH    800
00986:  POP     1D6
....................                               set_motor_pwm_duty(1,2,duty);  
00988:  PUSH    800
0098A:  POP     1D8
....................                               set_motor_pwm_duty(1,3,duty); 
0098C:  PUSH    800
0098E:  POP     1DA
....................                               set_motor_unit(1,1,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_1,2,2); 
00990:  MOV     #FEEE,W1
00992:  MOV     1C8,W2
00994:  MOV     #11,W3
00996:  AND     W2,W1,W2
00998:  IOR      W2,  W3,W2
0099A:  MOV     W2,1C8
0099C:  MOV     #FCFC,W1
0099E:  MOV     1D4,W2
009A0:  MOV     #1,W3
009A2:  AND     W2,W1,W2
009A4:  IOR      W2,  W3,W2
009A6:  MOV     W2,1D4
009A8:  MOV     #FCFE,W1
009AA:  MOV     1D0,W2
009AC:  MOV     #0,W3
009AE:  AND     W2,W1,W2
009B0:  IOR      W2,  W3,W2
009B2:  MOV     W2,1D0
009B4:  MOV     #FCFE,W1
009B6:  MOV     1D2,W2
009B8:  MOV     #0,W3
009BA:  AND     W2,W1,W2
009BC:  IOR      W2,  W3,W2
009BE:  MOV     W2,1D2
009C0:  BCLR.B  1CE.1
009C2:  BCLR.B  1CE.0
....................                               set_motor_unit(1,2,MPWM_ENABLE,2,2); 
009C4:  MOV     #FDDD,W1
009C6:  MOV     1C8,W2
009C8:  MOV     #22,W3
009CA:  AND     W2,W1,W2
009CC:  IOR      W2,  W3,W2
009CE:  MOV     W2,1C8
009D0:  MOV     #F3F3,W1
009D2:  MOV     1D4,W2
009D4:  MOV     #C00,W3
009D6:  AND     W2,W1,W2
009D8:  IOR      W2,  W3,W2
009DA:  MOV     W2,1D4
009DC:  MOV     #F3FD,W1
009DE:  MOV     1D0,W2
009E0:  MOV     #0,W3
009E2:  AND     W2,W1,W2
009E4:  IOR      W2,  W3,W2
009E6:  MOV     W2,1D0
009E8:  MOV     #F3FD,W1
009EA:  MOV     1D2,W2
009EC:  MOV     #0,W3
009EE:  AND     W2,W1,W2
009F0:  IOR      W2,  W3,W2
009F2:  MOV     W2,1D2
009F4:  BCLR.B  1CE.3
009F6:  BCLR.B  1CE.2
....................                               set_motor_unit(1,3,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
009F8:  MOV     #FBBB,W1
009FA:  MOV     1C8,W2
009FC:  MOV     #44,W3
009FE:  AND     W2,W1,W2
00A00:  IOR      W2,  W3,W2
00A02:  MOV     W2,1C8
00A04:  MOV     #CFCF,W1
00A06:  MOV     1D4,W2
00A08:  MOV     #0,W3
00A0A:  AND     W2,W1,W2
00A0C:  IOR      W2,  W3,W2
00A0E:  MOV     W2,1D4
00A10:  MOV     #CFFB,W1
00A12:  MOV     1D0,W2
00A14:  MOV     #0,W3
00A16:  AND     W2,W1,W2
00A18:  IOR      W2,  W3,W2
00A1A:  MOV     W2,1D0
00A1C:  MOV     #CFFB,W1
00A1E:  MOV     1D2,W2
00A20:  MOV     #0,W3
00A22:  AND     W2,W1,W2
00A24:  IOR      W2,  W3,W2
00A26:  MOV     W2,1D2
00A28:  BCLR.B  1CE.5
00A2A:  BCLR.B  1CE.4
....................                              // CNIE = 1; 
....................                               break; 
00A2C:  GOTO    F58
....................                  case(0x0003): 
....................                               set_motor_unit(1,1,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00A30:  MOV     #FEEE,W1
00A32:  MOV     1C8,W2
00A34:  MOV     #11,W3
00A36:  AND     W2,W1,W2
00A38:  IOR      W2,  W3,W2
00A3A:  MOV     W2,1C8
00A3C:  MOV     #FCFC,W1
00A3E:  MOV     1D4,W2
00A40:  MOV     #0,W3
00A42:  AND     W2,W1,W2
00A44:  IOR      W2,  W3,W2
00A46:  MOV     W2,1D4
00A48:  MOV     #FCFE,W1
00A4A:  MOV     1D0,W2
00A4C:  MOV     #0,W3
00A4E:  AND     W2,W1,W2
00A50:  IOR      W2,  W3,W2
00A52:  MOV     W2,1D0
00A54:  MOV     #FCFE,W1
00A56:  MOV     1D2,W2
00A58:  MOV     #0,W3
00A5A:  AND     W2,W1,W2
00A5C:  IOR      W2,  W3,W2
00A5E:  MOV     W2,1D2
00A60:  BCLR.B  1CE.1
00A62:  BCLR.B  1CE.0
....................                               set_motor_unit(1,2,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00A64:  MOV     #FDDD,W1
00A66:  MOV     1C8,W2
00A68:  MOV     #22,W3
00A6A:  AND     W2,W1,W2
00A6C:  IOR      W2,  W3,W2
00A6E:  MOV     W2,1C8
00A70:  MOV     #F3F3,W1
00A72:  MOV     1D4,W2
00A74:  MOV     #0,W3
00A76:  AND     W2,W1,W2
00A78:  IOR      W2,  W3,W2
00A7A:  MOV     W2,1D4
00A7C:  MOV     #F3FD,W1
00A7E:  MOV     1D0,W2
00A80:  MOV     #0,W3
00A82:  AND     W2,W1,W2
00A84:  IOR      W2,  W3,W2
00A86:  MOV     W2,1D0
00A88:  MOV     #F3FD,W1
00A8A:  MOV     1D2,W2
00A8C:  MOV     #0,W3
00A8E:  AND     W2,W1,W2
00A90:  IOR      W2,  W3,W2
00A92:  MOV     W2,1D2
00A94:  BCLR.B  1CE.3
00A96:  BCLR.B  1CE.2
....................                               set_motor_unit(1,3,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00A98:  MOV     #FBBB,W1
00A9A:  MOV     1C8,W2
00A9C:  MOV     #44,W3
00A9E:  AND     W2,W1,W2
00AA0:  IOR      W2,  W3,W2
00AA2:  MOV     W2,1C8
00AA4:  MOV     #CFCF,W1
00AA6:  MOV     1D4,W2
00AA8:  MOV     #0,W3
00AAA:  AND     W2,W1,W2
00AAC:  IOR      W2,  W3,W2
00AAE:  MOV     W2,1D4
00AB0:  MOV     #CFFB,W1
00AB2:  MOV     1D0,W2
00AB4:  MOV     #0,W3
00AB6:  AND     W2,W1,W2
00AB8:  IOR      W2,  W3,W2
00ABA:  MOV     W2,1D0
00ABC:  MOV     #CFFB,W1
00ABE:  MOV     1D2,W2
00AC0:  MOV     #0,W3
00AC2:  AND     W2,W1,W2
00AC4:  IOR      W2,  W3,W2
00AC6:  MOV     W2,1D2
00AC8:  BCLR.B  1CE.5
00ACA:  BCLR.B  1CE.4
....................                               set_motor_pwm_duty(1,1,duty);  
00ACC:  PUSH    800
00ACE:  POP     1D6
....................                               set_motor_pwm_duty(1,2,duty);  
00AD0:  PUSH    800
00AD2:  POP     1D8
....................                               set_motor_pwm_duty(1,3,duty); 
00AD4:  PUSH    800
00AD6:  POP     1DA
....................                               set_motor_unit(1,1,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00AD8:  MOV     #FEEE,W1
00ADA:  MOV     1C8,W2
00ADC:  MOV     #11,W3
00ADE:  AND     W2,W1,W2
00AE0:  IOR      W2,  W3,W2
00AE2:  MOV     W2,1C8
00AE4:  MOV     #FCFC,W1
00AE6:  MOV     1D4,W2
00AE8:  MOV     #0,W3
00AEA:  AND     W2,W1,W2
00AEC:  IOR      W2,  W3,W2
00AEE:  MOV     W2,1D4
00AF0:  MOV     #FCFE,W1
00AF2:  MOV     1D0,W2
00AF4:  MOV     #0,W3
00AF6:  AND     W2,W1,W2
00AF8:  IOR      W2,  W3,W2
00AFA:  MOV     W2,1D0
00AFC:  MOV     #FCFE,W1
00AFE:  MOV     1D2,W2
00B00:  MOV     #0,W3
00B02:  AND     W2,W1,W2
00B04:  IOR      W2,  W3,W2
00B06:  MOV     W2,1D2
00B08:  BCLR.B  1CE.1
00B0A:  BCLR.B  1CE.0
....................                               set_motor_unit(1,2,MPWM_ENABLE,2,2); 
00B0C:  MOV     #FDDD,W1
00B0E:  MOV     1C8,W2
00B10:  MOV     #22,W3
00B12:  AND     W2,W1,W2
00B14:  IOR      W2,  W3,W2
00B16:  MOV     W2,1C8
00B18:  MOV     #F3F3,W1
00B1A:  MOV     1D4,W2
00B1C:  MOV     #C00,W3
00B1E:  AND     W2,W1,W2
00B20:  IOR      W2,  W3,W2
00B22:  MOV     W2,1D4
00B24:  MOV     #F3FD,W1
00B26:  MOV     1D0,W2
00B28:  MOV     #0,W3
00B2A:  AND     W2,W1,W2
00B2C:  IOR      W2,  W3,W2
00B2E:  MOV     W2,1D0
00B30:  MOV     #F3FD,W1
00B32:  MOV     1D2,W2
00B34:  MOV     #0,W3
00B36:  AND     W2,W1,W2
00B38:  IOR      W2,  W3,W2
00B3A:  MOV     W2,1D2
00B3C:  BCLR.B  1CE.3
00B3E:  BCLR.B  1CE.2
....................                               set_motor_unit(1,3,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_1,2,2); 
00B40:  MOV     #FBBB,W1
00B42:  MOV     1C8,W2
00B44:  MOV     #44,W3
00B46:  AND     W2,W1,W2
00B48:  IOR      W2,  W3,W2
00B4A:  MOV     W2,1C8
00B4C:  MOV     #CFCF,W1
00B4E:  MOV     1D4,W2
00B50:  MOV     #10,W3
00B52:  AND     W2,W1,W2
00B54:  IOR      W2,  W3,W2
00B56:  MOV     W2,1D4
00B58:  MOV     #CFFB,W1
00B5A:  MOV     1D0,W2
00B5C:  MOV     #0,W3
00B5E:  AND     W2,W1,W2
00B60:  IOR      W2,  W3,W2
00B62:  MOV     W2,1D0
00B64:  MOV     #CFFB,W1
00B66:  MOV     1D2,W2
00B68:  MOV     #0,W3
00B6A:  AND     W2,W1,W2
00B6C:  IOR      W2,  W3,W2
00B6E:  MOV     W2,1D2
00B70:  BCLR.B  1CE.5
00B72:  BCLR.B  1CE.4
....................                              // CNIE = 1; 
....................                               break; 
00B74:  GOTO    F58
....................                  case(0x0004): 
....................                               set_motor_unit(1,1,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00B78:  MOV     #FEEE,W1
00B7A:  MOV     1C8,W2
00B7C:  MOV     #11,W3
00B7E:  AND     W2,W1,W2
00B80:  IOR      W2,  W3,W2
00B82:  MOV     W2,1C8
00B84:  MOV     #FCFC,W1
00B86:  MOV     1D4,W2
00B88:  MOV     #0,W3
00B8A:  AND     W2,W1,W2
00B8C:  IOR      W2,  W3,W2
00B8E:  MOV     W2,1D4
00B90:  MOV     #FCFE,W1
00B92:  MOV     1D0,W2
00B94:  MOV     #0,W3
00B96:  AND     W2,W1,W2
00B98:  IOR      W2,  W3,W2
00B9A:  MOV     W2,1D0
00B9C:  MOV     #FCFE,W1
00B9E:  MOV     1D2,W2
00BA0:  MOV     #0,W3
00BA2:  AND     W2,W1,W2
00BA4:  IOR      W2,  W3,W2
00BA6:  MOV     W2,1D2
00BA8:  BCLR.B  1CE.1
00BAA:  BCLR.B  1CE.0
....................                               set_motor_unit(1,2,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00BAC:  MOV     #FDDD,W1
00BAE:  MOV     1C8,W2
00BB0:  MOV     #22,W3
00BB2:  AND     W2,W1,W2
00BB4:  IOR      W2,  W3,W2
00BB6:  MOV     W2,1C8
00BB8:  MOV     #F3F3,W1
00BBA:  MOV     1D4,W2
00BBC:  MOV     #0,W3
00BBE:  AND     W2,W1,W2
00BC0:  IOR      W2,  W3,W2
00BC2:  MOV     W2,1D4
00BC4:  MOV     #F3FD,W1
00BC6:  MOV     1D0,W2
00BC8:  MOV     #0,W3
00BCA:  AND     W2,W1,W2
00BCC:  IOR      W2,  W3,W2
00BCE:  MOV     W2,1D0
00BD0:  MOV     #F3FD,W1
00BD2:  MOV     1D2,W2
00BD4:  MOV     #0,W3
00BD6:  AND     W2,W1,W2
00BD8:  IOR      W2,  W3,W2
00BDA:  MOV     W2,1D2
00BDC:  BCLR.B  1CE.3
00BDE:  BCLR.B  1CE.2
....................                               set_motor_unit(1,3,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00BE0:  MOV     #FBBB,W1
00BE2:  MOV     1C8,W2
00BE4:  MOV     #44,W3
00BE6:  AND     W2,W1,W2
00BE8:  IOR      W2,  W3,W2
00BEA:  MOV     W2,1C8
00BEC:  MOV     #CFCF,W1
00BEE:  MOV     1D4,W2
00BF0:  MOV     #0,W3
00BF2:  AND     W2,W1,W2
00BF4:  IOR      W2,  W3,W2
00BF6:  MOV     W2,1D4
00BF8:  MOV     #CFFB,W1
00BFA:  MOV     1D0,W2
00BFC:  MOV     #0,W3
00BFE:  AND     W2,W1,W2
00C00:  IOR      W2,  W3,W2
00C02:  MOV     W2,1D0
00C04:  MOV     #CFFB,W1
00C06:  MOV     1D2,W2
00C08:  MOV     #0,W3
00C0A:  AND     W2,W1,W2
00C0C:  IOR      W2,  W3,W2
00C0E:  MOV     W2,1D2
00C10:  BCLR.B  1CE.5
00C12:  BCLR.B  1CE.4
....................                               set_motor_pwm_duty(1,1,duty);  
00C14:  PUSH    800
00C16:  POP     1D6
....................                               set_motor_pwm_duty(1,2,duty);  
00C18:  PUSH    800
00C1A:  POP     1D8
....................                               set_motor_pwm_duty(1,3,duty); 
00C1C:  PUSH    800
00C1E:  POP     1DA
....................                               set_motor_unit(1,1,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00C20:  MOV     #FEEE,W1
00C22:  MOV     1C8,W2
00C24:  MOV     #11,W3
00C26:  AND     W2,W1,W2
00C28:  IOR      W2,  W3,W2
00C2A:  MOV     W2,1C8
00C2C:  MOV     #FCFC,W1
00C2E:  MOV     1D4,W2
00C30:  MOV     #0,W3
00C32:  AND     W2,W1,W2
00C34:  IOR      W2,  W3,W2
00C36:  MOV     W2,1D4
00C38:  MOV     #FCFE,W1
00C3A:  MOV     1D0,W2
00C3C:  MOV     #0,W3
00C3E:  AND     W2,W1,W2
00C40:  IOR      W2,  W3,W2
00C42:  MOV     W2,1D0
00C44:  MOV     #FCFE,W1
00C46:  MOV     1D2,W2
00C48:  MOV     #0,W3
00C4A:  AND     W2,W1,W2
00C4C:  IOR      W2,  W3,W2
00C4E:  MOV     W2,1D2
00C50:  BCLR.B  1CE.1
00C52:  BCLR.B  1CE.0
....................                               set_motor_unit(1,2,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_1,2,2); 
00C54:  MOV     #FDDD,W1
00C56:  MOV     1C8,W2
00C58:  MOV     #22,W3
00C5A:  AND     W2,W1,W2
00C5C:  IOR      W2,  W3,W2
00C5E:  MOV     W2,1C8
00C60:  MOV     #F3F3,W1
00C62:  MOV     1D4,W2
00C64:  MOV     #4,W3
00C66:  AND     W2,W1,W2
00C68:  IOR      W2,  W3,W2
00C6A:  MOV     W2,1D4
00C6C:  MOV     #F3FD,W1
00C6E:  MOV     1D0,W2
00C70:  MOV     #0,W3
00C72:  AND     W2,W1,W2
00C74:  IOR      W2,  W3,W2
00C76:  MOV     W2,1D0
00C78:  MOV     #F3FD,W1
00C7A:  MOV     1D2,W2
00C7C:  MOV     #0,W3
00C7E:  AND     W2,W1,W2
00C80:  IOR      W2,  W3,W2
00C82:  MOV     W2,1D2
00C84:  BCLR.B  1CE.3
00C86:  BCLR.B  1CE.2
....................                               set_motor_unit(1,3,MPWM_ENABLE,2,2); 
00C88:  MOV     #FBBB,W1
00C8A:  MOV     1C8,W2
00C8C:  MOV     #44,W3
00C8E:  AND     W2,W1,W2
00C90:  IOR      W2,  W3,W2
00C92:  MOV     W2,1C8
00C94:  MOV     #CFCF,W1
00C96:  MOV     1D4,W2
00C98:  MOV     #3000,W3
00C9A:  AND     W2,W1,W2
00C9C:  IOR      W2,  W3,W2
00C9E:  MOV     W2,1D4
00CA0:  MOV     #CFFB,W1
00CA2:  MOV     1D0,W2
00CA4:  MOV     #0,W3
00CA6:  AND     W2,W1,W2
00CA8:  IOR      W2,  W3,W2
00CAA:  MOV     W2,1D0
00CAC:  MOV     #CFFB,W1
00CAE:  MOV     1D2,W2
00CB0:  MOV     #0,W3
00CB2:  AND     W2,W1,W2
00CB4:  IOR      W2,  W3,W2
00CB6:  MOV     W2,1D2
00CB8:  BCLR.B  1CE.5
00CBA:  BCLR.B  1CE.4
....................                              // CNIE = 1; 
....................                               break; 
00CBC:  GOTO    F58
....................                  case(0x0005): 
....................                               set_motor_unit(1,1,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00CC0:  MOV     #FEEE,W1
00CC2:  MOV     1C8,W2
00CC4:  MOV     #11,W3
00CC6:  AND     W2,W1,W2
00CC8:  IOR      W2,  W3,W2
00CCA:  MOV     W2,1C8
00CCC:  MOV     #FCFC,W1
00CCE:  MOV     1D4,W2
00CD0:  MOV     #0,W3
00CD2:  AND     W2,W1,W2
00CD4:  IOR      W2,  W3,W2
00CD6:  MOV     W2,1D4
00CD8:  MOV     #FCFE,W1
00CDA:  MOV     1D0,W2
00CDC:  MOV     #0,W3
00CDE:  AND     W2,W1,W2
00CE0:  IOR      W2,  W3,W2
00CE2:  MOV     W2,1D0
00CE4:  MOV     #FCFE,W1
00CE6:  MOV     1D2,W2
00CE8:  MOV     #0,W3
00CEA:  AND     W2,W1,W2
00CEC:  IOR      W2,  W3,W2
00CEE:  MOV     W2,1D2
00CF0:  BCLR.B  1CE.1
00CF2:  BCLR.B  1CE.0
....................                               set_motor_unit(1,2,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00CF4:  MOV     #FDDD,W1
00CF6:  MOV     1C8,W2
00CF8:  MOV     #22,W3
00CFA:  AND     W2,W1,W2
00CFC:  IOR      W2,  W3,W2
00CFE:  MOV     W2,1C8
00D00:  MOV     #F3F3,W1
00D02:  MOV     1D4,W2
00D04:  MOV     #0,W3
00D06:  AND     W2,W1,W2
00D08:  IOR      W2,  W3,W2
00D0A:  MOV     W2,1D4
00D0C:  MOV     #F3FD,W1
00D0E:  MOV     1D0,W2
00D10:  MOV     #0,W3
00D12:  AND     W2,W1,W2
00D14:  IOR      W2,  W3,W2
00D16:  MOV     W2,1D0
00D18:  MOV     #F3FD,W1
00D1A:  MOV     1D2,W2
00D1C:  MOV     #0,W3
00D1E:  AND     W2,W1,W2
00D20:  IOR      W2,  W3,W2
00D22:  MOV     W2,1D2
00D24:  BCLR.B  1CE.3
00D26:  BCLR.B  1CE.2
....................                               set_motor_unit(1,3,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00D28:  MOV     #FBBB,W1
00D2A:  MOV     1C8,W2
00D2C:  MOV     #44,W3
00D2E:  AND     W2,W1,W2
00D30:  IOR      W2,  W3,W2
00D32:  MOV     W2,1C8
00D34:  MOV     #CFCF,W1
00D36:  MOV     1D4,W2
00D38:  MOV     #0,W3
00D3A:  AND     W2,W1,W2
00D3C:  IOR      W2,  W3,W2
00D3E:  MOV     W2,1D4
00D40:  MOV     #CFFB,W1
00D42:  MOV     1D0,W2
00D44:  MOV     #0,W3
00D46:  AND     W2,W1,W2
00D48:  IOR      W2,  W3,W2
00D4A:  MOV     W2,1D0
00D4C:  MOV     #CFFB,W1
00D4E:  MOV     1D2,W2
00D50:  MOV     #0,W3
00D52:  AND     W2,W1,W2
00D54:  IOR      W2,  W3,W2
00D56:  MOV     W2,1D2
00D58:  BCLR.B  1CE.5
00D5A:  BCLR.B  1CE.4
....................                               set_motor_pwm_duty(1,1,duty);  
00D5C:  PUSH    800
00D5E:  POP     1D6
....................                               set_motor_pwm_duty(1,2,duty);  
00D60:  PUSH    800
00D62:  POP     1D8
....................                               set_motor_pwm_duty(1,3,duty); 
00D64:  PUSH    800
00D66:  POP     1DA
....................                               set_motor_unit(1,1,MPWM_ENABLE,2,2); 
00D68:  MOV     #FEEE,W1
00D6A:  MOV     1C8,W2
00D6C:  MOV     #11,W3
00D6E:  AND     W2,W1,W2
00D70:  IOR      W2,  W3,W2
00D72:  MOV     W2,1C8
00D74:  MOV     #FCFC,W1
00D76:  MOV     1D4,W2
00D78:  MOV     #300,W3
00D7A:  AND     W2,W1,W2
00D7C:  IOR      W2,  W3,W2
00D7E:  MOV     W2,1D4
00D80:  MOV     #FCFE,W1
00D82:  MOV     1D0,W2
00D84:  MOV     #0,W3
00D86:  AND     W2,W1,W2
00D88:  IOR      W2,  W3,W2
00D8A:  MOV     W2,1D0
00D8C:  MOV     #FCFE,W1
00D8E:  MOV     1D2,W2
00D90:  MOV     #0,W3
00D92:  AND     W2,W1,W2
00D94:  IOR      W2,  W3,W2
00D96:  MOV     W2,1D2
00D98:  BCLR.B  1CE.1
00D9A:  BCLR.B  1CE.0
....................                               set_motor_unit(1,2,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_1,2,2); 
00D9C:  MOV     #FDDD,W1
00D9E:  MOV     1C8,W2
00DA0:  MOV     #22,W3
00DA2:  AND     W2,W1,W2
00DA4:  IOR      W2,  W3,W2
00DA6:  MOV     W2,1C8
00DA8:  MOV     #F3F3,W1
00DAA:  MOV     1D4,W2
00DAC:  MOV     #4,W3
00DAE:  AND     W2,W1,W2
00DB0:  IOR      W2,  W3,W2
00DB2:  MOV     W2,1D4
00DB4:  MOV     #F3FD,W1
00DB6:  MOV     1D0,W2
00DB8:  MOV     #0,W3
00DBA:  AND     W2,W1,W2
00DBC:  IOR      W2,  W3,W2
00DBE:  MOV     W2,1D0
00DC0:  MOV     #F3FD,W1
00DC2:  MOV     1D2,W2
00DC4:  MOV     #0,W3
00DC6:  AND     W2,W1,W2
00DC8:  IOR      W2,  W3,W2
00DCA:  MOV     W2,1D2
00DCC:  BCLR.B  1CE.3
00DCE:  BCLR.B  1CE.2
....................                               set_motor_unit(1,3,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00DD0:  MOV     #FBBB,W1
00DD2:  MOV     1C8,W2
00DD4:  MOV     #44,W3
00DD6:  AND     W2,W1,W2
00DD8:  IOR      W2,  W3,W2
00DDA:  MOV     W2,1C8
00DDC:  MOV     #CFCF,W1
00DDE:  MOV     1D4,W2
00DE0:  MOV     #0,W3
00DE2:  AND     W2,W1,W2
00DE4:  IOR      W2,  W3,W2
00DE6:  MOV     W2,1D4
00DE8:  MOV     #CFFB,W1
00DEA:  MOV     1D0,W2
00DEC:  MOV     #0,W3
00DEE:  AND     W2,W1,W2
00DF0:  IOR      W2,  W3,W2
00DF2:  MOV     W2,1D0
00DF4:  MOV     #CFFB,W1
00DF6:  MOV     1D2,W2
00DF8:  MOV     #0,W3
00DFA:  AND     W2,W1,W2
00DFC:  IOR      W2,  W3,W2
00DFE:  MOV     W2,1D2
00E00:  BCLR.B  1CE.5
00E02:  BCLR.B  1CE.4
....................                              // CNIE = 1; 
....................                               break; 
00E04:  GOTO    F58
....................                  case(0x0006): 
....................                               set_motor_unit(1,1,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00E08:  MOV     #FEEE,W1
00E0A:  MOV     1C8,W2
00E0C:  MOV     #11,W3
00E0E:  AND     W2,W1,W2
00E10:  IOR      W2,  W3,W2
00E12:  MOV     W2,1C8
00E14:  MOV     #FCFC,W1
00E16:  MOV     1D4,W2
00E18:  MOV     #0,W3
00E1A:  AND     W2,W1,W2
00E1C:  IOR      W2,  W3,W2
00E1E:  MOV     W2,1D4
00E20:  MOV     #FCFE,W1
00E22:  MOV     1D0,W2
00E24:  MOV     #0,W3
00E26:  AND     W2,W1,W2
00E28:  IOR      W2,  W3,W2
00E2A:  MOV     W2,1D0
00E2C:  MOV     #FCFE,W1
00E2E:  MOV     1D2,W2
00E30:  MOV     #0,W3
00E32:  AND     W2,W1,W2
00E34:  IOR      W2,  W3,W2
00E36:  MOV     W2,1D2
00E38:  BCLR.B  1CE.1
00E3A:  BCLR.B  1CE.0
....................                               set_motor_unit(1,2,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00E3C:  MOV     #FDDD,W1
00E3E:  MOV     1C8,W2
00E40:  MOV     #22,W3
00E42:  AND     W2,W1,W2
00E44:  IOR      W2,  W3,W2
00E46:  MOV     W2,1C8
00E48:  MOV     #F3F3,W1
00E4A:  MOV     1D4,W2
00E4C:  MOV     #0,W3
00E4E:  AND     W2,W1,W2
00E50:  IOR      W2,  W3,W2
00E52:  MOV     W2,1D4
00E54:  MOV     #F3FD,W1
00E56:  MOV     1D0,W2
00E58:  MOV     #0,W3
00E5A:  AND     W2,W1,W2
00E5C:  IOR      W2,  W3,W2
00E5E:  MOV     W2,1D0
00E60:  MOV     #F3FD,W1
00E62:  MOV     1D2,W2
00E64:  MOV     #0,W3
00E66:  AND     W2,W1,W2
00E68:  IOR      W2,  W3,W2
00E6A:  MOV     W2,1D2
00E6C:  BCLR.B  1CE.3
00E6E:  BCLR.B  1CE.2
....................                               set_motor_unit(1,3,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00E70:  MOV     #FBBB,W1
00E72:  MOV     1C8,W2
00E74:  MOV     #44,W3
00E76:  AND     W2,W1,W2
00E78:  IOR      W2,  W3,W2
00E7A:  MOV     W2,1C8
00E7C:  MOV     #CFCF,W1
00E7E:  MOV     1D4,W2
00E80:  MOV     #0,W3
00E82:  AND     W2,W1,W2
00E84:  IOR      W2,  W3,W2
00E86:  MOV     W2,1D4
00E88:  MOV     #CFFB,W1
00E8A:  MOV     1D0,W2
00E8C:  MOV     #0,W3
00E8E:  AND     W2,W1,W2
00E90:  IOR      W2,  W3,W2
00E92:  MOV     W2,1D0
00E94:  MOV     #CFFB,W1
00E96:  MOV     1D2,W2
00E98:  MOV     #0,W3
00E9A:  AND     W2,W1,W2
00E9C:  IOR      W2,  W3,W2
00E9E:  MOV     W2,1D2
00EA0:  BCLR.B  1CE.5
00EA2:  BCLR.B  1CE.4
....................                               set_motor_pwm_duty(1,1,duty);  
00EA4:  PUSH    800
00EA6:  POP     1D6
....................                               set_motor_pwm_duty(1,2,duty);  
00EA8:  PUSH    800
00EAA:  POP     1D8
....................                               set_motor_pwm_duty(1,3,duty); 
00EAC:  PUSH    800
00EAE:  POP     1DA
....................                               set_motor_unit(1,1,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_1,2,2); 
00EB0:  MOV     #FEEE,W1
00EB2:  MOV     1C8,W2
00EB4:  MOV     #11,W3
00EB6:  AND     W2,W1,W2
00EB8:  IOR      W2,  W3,W2
00EBA:  MOV     W2,1C8
00EBC:  MOV     #FCFC,W1
00EBE:  MOV     1D4,W2
00EC0:  MOV     #1,W3
00EC2:  AND     W2,W1,W2
00EC4:  IOR      W2,  W3,W2
00EC6:  MOV     W2,1D4
00EC8:  MOV     #FCFE,W1
00ECA:  MOV     1D0,W2
00ECC:  MOV     #0,W3
00ECE:  AND     W2,W1,W2
00ED0:  IOR      W2,  W3,W2
00ED2:  MOV     W2,1D0
00ED4:  MOV     #FCFE,W1
00ED6:  MOV     1D2,W2
00ED8:  MOV     #0,W3
00EDA:  AND     W2,W1,W2
00EDC:  IOR      W2,  W3,W2
00EDE:  MOV     W2,1D2
00EE0:  BCLR.B  1CE.1
00EE2:  BCLR.B  1CE.0
....................                               set_motor_unit(1,2,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00EE4:  MOV     #FDDD,W1
00EE6:  MOV     1C8,W2
00EE8:  MOV     #22,W3
00EEA:  AND     W2,W1,W2
00EEC:  IOR      W2,  W3,W2
00EEE:  MOV     W2,1C8
00EF0:  MOV     #F3F3,W1
00EF2:  MOV     1D4,W2
00EF4:  MOV     #0,W3
00EF6:  AND     W2,W1,W2
00EF8:  IOR      W2,  W3,W2
00EFA:  MOV     W2,1D4
00EFC:  MOV     #F3FD,W1
00EFE:  MOV     1D0,W2
00F00:  MOV     #0,W3
00F02:  AND     W2,W1,W2
00F04:  IOR      W2,  W3,W2
00F06:  MOV     W2,1D0
00F08:  MOV     #F3FD,W1
00F0A:  MOV     1D2,W2
00F0C:  MOV     #0,W3
00F0E:  AND     W2,W1,W2
00F10:  IOR      W2,  W3,W2
00F12:  MOV     W2,1D2
00F14:  BCLR.B  1CE.3
00F16:  BCLR.B  1CE.2
....................                               set_motor_unit(1,3,MPWM_ENABLE,2,2); 
00F18:  MOV     #FBBB,W1
00F1A:  MOV     1C8,W2
00F1C:  MOV     #44,W3
00F1E:  AND     W2,W1,W2
00F20:  IOR      W2,  W3,W2
00F22:  MOV     W2,1C8
00F24:  MOV     #CFCF,W1
00F26:  MOV     1D4,W2
00F28:  MOV     #3000,W3
00F2A:  AND     W2,W1,W2
00F2C:  IOR      W2,  W3,W2
00F2E:  MOV     W2,1D4
00F30:  MOV     #CFFB,W1
00F32:  MOV     1D0,W2
00F34:  MOV     #0,W3
00F36:  AND     W2,W1,W2
00F38:  IOR      W2,  W3,W2
00F3A:  MOV     W2,1D0
00F3C:  MOV     #CFFB,W1
00F3E:  MOV     1D2,W2
00F40:  MOV     #0,W3
00F42:  AND     W2,W1,W2
00F44:  IOR      W2,  W3,W2
00F46:  MOV     W2,1D2
00F48:  BCLR.B  1CE.5
00F4A:  BCLR.B  1CE.4
....................                              // CNIE = 1; 
....................                               break; 
00F4C:  GOTO    F58
....................                  case(0x0007): 
....................                               zera_pwm();                       
00F50:  CALL    6AA
....................                               //CNIE = 1; 
....................                               break; 
00F54:  GOTO    F58
....................      } 
....................      //CNIE = 1; 
....................      //enable_interrupts(INT_TIMER1); 
....................      enable_interrupts(INTR_CN_PIN|PIN_B1); 
00F58:  BSET.B  60.5
00F5A:  BSET.B  96.3
....................      enable_interrupts(INTR_CN_PIN|PIN_B2); 
00F5C:  BSET.B  60.6
00F5E:  BSET.B  96.3
....................      enable_interrupts(INTR_CN_PIN|PIN_B3); 
00F60:  BSET.B  60.7
00F62:  BSET.B  96.3
.................... } 
....................  
00F64:  BCLR.B  86.3
00F66:  MOV     #1A,W0
00F68:  REPEAT  #C
00F6A:  MOV     [--W15],[W0--]
00F6C:  MOV     [--W15],W0
00F6E:  POP     36
00F70:  POP     42
00F72:  RETFIE  
.................... void zera_pwm() 
.................... { 
....................     set_motor_unit(1,1,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
*
006AA:  MOV     #FEEE,W1
006AC:  MOV     1C8,W2
006AE:  MOV     #11,W3
006B0:  AND     W2,W1,W2
006B2:  IOR      W2,  W3,W2
006B4:  MOV     W2,1C8
006B6:  MOV     #FCFC,W1
006B8:  MOV     1D4,W2
006BA:  MOV     #0,W3
006BC:  AND     W2,W1,W2
006BE:  IOR      W2,  W3,W2
006C0:  MOV     W2,1D4
006C2:  MOV     #FCFE,W1
006C4:  MOV     1D0,W2
006C6:  MOV     #0,W3
006C8:  AND     W2,W1,W2
006CA:  IOR      W2,  W3,W2
006CC:  MOV     W2,1D0
006CE:  MOV     #FCFE,W1
006D0:  MOV     1D2,W2
006D2:  MOV     #0,W3
006D4:  AND     W2,W1,W2
006D6:  IOR      W2,  W3,W2
006D8:  MOV     W2,1D2
006DA:  BCLR.B  1CE.1
006DC:  BCLR.B  1CE.0
....................     set_motor_unit(1,2,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
006DE:  MOV     #FDDD,W1
006E0:  MOV     1C8,W2
006E2:  MOV     #22,W3
006E4:  AND     W2,W1,W2
006E6:  IOR      W2,  W3,W2
006E8:  MOV     W2,1C8
006EA:  MOV     #F3F3,W1
006EC:  MOV     1D4,W2
006EE:  MOV     #0,W3
006F0:  AND     W2,W1,W2
006F2:  IOR      W2,  W3,W2
006F4:  MOV     W2,1D4
006F6:  MOV     #F3FD,W1
006F8:  MOV     1D0,W2
006FA:  MOV     #0,W3
006FC:  AND     W2,W1,W2
006FE:  IOR      W2,  W3,W2
00700:  MOV     W2,1D0
00702:  MOV     #F3FD,W1
00704:  MOV     1D2,W2
00706:  MOV     #0,W3
00708:  AND     W2,W1,W2
0070A:  IOR      W2,  W3,W2
0070C:  MOV     W2,1D2
0070E:  BCLR.B  1CE.3
00710:  BCLR.B  1CE.2
....................     set_motor_unit(1,3,MPWM_ENABLE|MPWM_FORCE_H_0|MPWM_FORCE_L_0,2,2); 
00712:  MOV     #FBBB,W1
00714:  MOV     1C8,W2
00716:  MOV     #44,W3
00718:  AND     W2,W1,W2
0071A:  IOR      W2,  W3,W2
0071C:  MOV     W2,1C8
0071E:  MOV     #CFCF,W1
00720:  MOV     1D4,W2
00722:  MOV     #0,W3
00724:  AND     W2,W1,W2
00726:  IOR      W2,  W3,W2
00728:  MOV     W2,1D4
0072A:  MOV     #CFFB,W1
0072C:  MOV     1D0,W2
0072E:  MOV     #0,W3
00730:  AND     W2,W1,W2
00732:  IOR      W2,  W3,W2
00734:  MOV     W2,1D0
00736:  MOV     #CFFB,W1
00738:  MOV     1D2,W2
0073A:  MOV     #0,W3
0073C:  AND     W2,W1,W2
0073E:  IOR      W2,  W3,W2
00740:  MOV     W2,1D2
00742:  BCLR.B  1CE.5
00744:  BCLR.B  1CE.4
.................... } 
00746:  RETURN  
....................  
.................... void inicializa_oscilador(){ 
....................  
....................    PLLPRE_1 = 0; 
*
00F74:  BCLR.B  744.0
....................    PLLPRE_2 = 0; 
00F76:  BCLR.B  744.1
....................    PLLPRE_3 = 0; 
00F78:  BCLR.B  744.2
....................    PLLPRE_4 = 0; 
00F7A:  BCLR.B  744.3
....................    PLLPRE_5 = 0; 
00F7C:  BCLR.B  744.4
....................    PLLDIV_1 = 0; 
00F7E:  BCLR.B  746.0
....................    PLLDIV_2 = 1; 
00F80:  BSET.B  746.1
....................    PLLDIV_3 = 1; 
00F82:  BSET.B  746.2
....................    PLLDIV_4 = 1; 
00F84:  BSET.B  746.3
....................    PLLDIV_5 = 0; 
00F86:  BCLR.B  746.4
....................    PLLDIV_6 = 0; 
00F88:  BCLR.B  746.5
....................    PLLDIV_7 = 1; 
00F8A:  BSET.B  746.6
....................    PLLDIV_8 = 0; 
00F8C:  BCLR.B  746.7
....................    PLLDIV_9 = 0; 
00F8E:  BCLR.B  747.0
....................    PLLPOST_1 = 0; 
00F90:  BCLR.B  744.6
....................    PLLPOST_2 = 0; 
00F92:  BCLR.B  744.7
....................  
.................... } 
00F94:  RETURN  
....................  
.................... void inicializa_perifericos_variaveis(){ 
....................  
....................    setup_spi( FALSE ); 
00F96:  BCLR.B  241.7
....................    setup_spi2( FALSE ); 
00F98:  BCLR.B  261.7
....................    setup_qei(QEI_MODE_X4 | QEI_SWAP_AB, QEI_NO_ERROR_INTS| QEI_FILTER_DIV_64 | QEI_IDX_WHEN_A0_B0,1000); //QEI_RESET_WHEN_IDX_PULSE 
00F9A:  MOV     #680,W4
00F9C:  MOV     W4,1E0
00F9E:  MOV     #150,W4
00FA0:  MOV     W4,1E2
00FA2:  MOV     #3E8,W4
00FA4:  MOV     W4,1E6
00FA6:  CLR     1E4
....................     
....................    //INICIALIZA ADC 
....................    setup_adc(ADC_CLOCK_INTERNAL); 
00FA8:  MOV     #8000,W4
00FAA:  MOV     W4,324
00FAC:  MOV     #80E0,W4
00FAE:  MOV     W4,320
....................    setup_adc_ports(sAN2|VSS_VDD); 
00FB0:  MOV     #FFFB,W4
00FB2:  MOV     W4,32C
00FB4:  CLR     322
....................    set_adc_channel(2); 
00FB6:  MOV     #2,W4
00FB8:  MOV     W4,328
....................     
....................    //INICIALIZA TIMER1 
....................     
....................    //setup_timer1(TMR_INTERNAL|TMR_DIV_BY_8, 0x1388); //1ms 
....................    //setup_timer1(TMR_INTERNAL|TMR_DIV_BY_8, 0xC350); //10ms 
....................    setup_timer1(TMR_INTERNAL|TMR_DIV_BY_64, 0x7A12); //50ms 
00FBA:  CLR     104
00FBC:  MOV     #7A12,W4
00FBE:  MOV     W4,102
00FC0:  MOV     #A020,W4
00FC2:  MOV     W4,104
....................    //setup_timer1(TMR_INTERNAL|TMR_DIV_BY_64, 0xF424); //100ms 
....................    //set_timer1(0xFFFF);  
....................     
....................    
....................    //INICIALIZA PWM 
....................    setup_motor_pwm(1,MPWM_FREE_RUN,1,1,5000); 
00FC4:  MOV     #8000,W4
00FC6:  MOV     W4,1C0
00FC8:  CLR.B   1CA
00FCA:  BSET.B  1D0.7
00FCC:  BSET.B  1D2.7
00FCE:  MOV     #10,W1
00FD0:  MOV     1C0,W2
00FD2:  AND     W2,#3,W2
00FD4:  IOR      W1,  W2,W1
00FD6:  PUSH    1C0
00FD8:  MOV.B   W1L,[W15-#2]
00FDA:  POP     1C0
00FDC:  MOV     #1388,W4
00FDE:  MOV     W4,1C4
....................                                                
....................    //set_motor_unit(1,1,MPWM_ENABLE | MPWM_FORCE_L_0,10,10); 
....................     
....................    set_motor_unit(1,1,MPWM_ENABLE|MPWM_FORCE_L_0|MPWM_FORCE_H_0,10,10);  
00FE0:  MOV     #FEEE,W1
00FE2:  MOV     1C8,W2
00FE4:  MOV     #11,W3
00FE6:  AND     W2,W1,W2
00FE8:  IOR      W2,  W3,W2
00FEA:  MOV     W2,1C8
00FEC:  MOV     #FCFC,W1
00FEE:  MOV     1D4,W2
00FF0:  MOV     #0,W3
00FF2:  AND     W2,W1,W2
00FF4:  IOR      W2,  W3,W2
00FF6:  MOV     W2,1D4
00FF8:  MOV     #FCFE,W1
00FFA:  MOV     1D0,W2
00FFC:  MOV     #0,W3
00FFE:  AND     W2,W1,W2
01000:  IOR      W2,  W3,W2
01002:  MOV     W2,1D0
01004:  MOV     #FCFE,W1
01006:  MOV     1D2,W2
01008:  MOV     #0,W3
0100A:  AND     W2,W1,W2
0100C:  IOR      W2,  W3,W2
0100E:  MOV     W2,1D2
01010:  MOV.B   #45,W0L
01012:  MOV.B   W0L,1CC
01014:  BCLR.B  1CE.1
01016:  BCLR.B  1CE.0
....................     
....................    set_motor_unit(1,2,MPWM_ENABLE|MPWM_FORCE_L_0|MPWM_FORCE_H_0,10,10);  
01018:  MOV     #FDDD,W1
0101A:  MOV     1C8,W2
0101C:  MOV     #22,W3
0101E:  AND     W2,W1,W2
01020:  IOR      W2,  W3,W2
01022:  MOV     W2,1C8
01024:  MOV     #F3F3,W1
01026:  MOV     1D4,W2
01028:  MOV     #0,W3
0102A:  AND     W2,W1,W2
0102C:  IOR      W2,  W3,W2
0102E:  MOV     W2,1D4
01030:  MOV     #F3FD,W1
01032:  MOV     1D0,W2
01034:  MOV     #0,W3
01036:  AND     W2,W1,W2
01038:  IOR      W2,  W3,W2
0103A:  MOV     W2,1D0
0103C:  MOV     #F3FD,W1
0103E:  MOV     1D2,W2
01040:  MOV     #0,W3
01042:  AND     W2,W1,W2
01044:  IOR      W2,  W3,W2
01046:  MOV     W2,1D2
01048:  BCLR.B  1CE.3
0104A:  BCLR.B  1CE.2
....................     
....................    set_motor_unit(1,3,MPWM_ENABLE|MPWM_FORCE_L_0|MPWM_FORCE_H_0,10,10); 
0104C:  MOV     #FBBB,W1
0104E:  MOV     1C8,W2
01050:  MOV     #44,W3
01052:  AND     W2,W1,W2
01054:  IOR      W2,  W3,W2
01056:  MOV     W2,1C8
01058:  MOV     #CFCF,W1
0105A:  MOV     1D4,W2
0105C:  MOV     #0,W3
0105E:  AND     W2,W1,W2
01060:  IOR      W2,  W3,W2
01062:  MOV     W2,1D4
01064:  MOV     #CFFB,W1
01066:  MOV     1D0,W2
01068:  MOV     #0,W3
0106A:  AND     W2,W1,W2
0106C:  IOR      W2,  W3,W2
0106E:  MOV     W2,1D0
01070:  MOV     #CFFB,W1
01072:  MOV     1D2,W2
01074:  MOV     #0,W3
01076:  AND     W2,W1,W2
01078:  IOR      W2,  W3,W2
0107A:  MOV     W2,1D2
0107C:  BCLR.B  1CE.5
0107E:  BCLR.B  1CE.4
....................     
....................    set_tris_b(0x001F);                                         
01080:  MOV     #1F,W4
01082:  MOV     W4,2C8
....................     
....................     
....................    set_motor_pwm_duty(1,1,duty);  //Set pin pair 1 to a 50% duty cycle. 
01084:  PUSH    800
01086:  POP     1D6
....................    set_motor_pwm_duty(1,2,duty);  //Set pin pair 2 to a 25% duty cycle. 
01088:  PUSH    800
0108A:  POP     1D8
....................    set_motor_pwm_duty(1,3,duty);  //Set pin pair 3 to a 50% duty cycle. 
0108C:  PUSH    800
0108E:  POP     1DA
....................  
....................  
....................    disable_interrupts(intr_global); 
01090:  BCLR.B  81.7
01092:  MOV     #E0,W4
01094:  MOV     W4,42
01096:  BSET.B  81.7
....................    disable_interrupts(int_timer5); 
01098:  BCLR.B  97.4
....................    disable_interrupts(INT_QEI); 
0109A:  BCLR.B  9B.2
.................... } 
0109C:  RETURN  
....................  
.................... void inicializa_interrupcao() 
.................... { 
....................   // CN2 = 1;                           //CN2, CN3 E CN4 ENTRADA HALL E PINOS DE INTERRUPO 
....................   // CN3 = 1; 
....................    //CN4 = 1; 
....................     
....................    //CNIF = 0;                           //RESETA FLAG DE INTERRUPO CN 
....................    enable_interrupts(INT_TIMER1); 
0109E:  BSET.B  94.3
....................    enable_interrupts(INTR_CN_PIN|PIN_B1); 
010A0:  BSET.B  60.5
010A2:  BSET.B  96.3
....................    enable_interrupts(INTR_CN_PIN|PIN_B2); 
010A4:  BSET.B  60.6
010A6:  BSET.B  96.3
....................    enable_interrupts(INTR_CN_PIN|PIN_B3); 
010A8:  BSET.B  60.7
010AA:  BSET.B  96.3
....................    enable_interrupts(INTR_GLOBAL); 
010AC:  BCLR.B  81.7
010AE:  CLR     42
010B0:  BSET.B  81.7
....................     
....................    //CNIE = 1;                           //ATIVA INTERRUPO CN 
.................... } 
010B2:  RETURN  
....................  
.................... void main() 
.................... { 
010B4:  MOV     #7444,W0
010B6:  MOV     W0,A4
010B8:  MOV     #4444,W0
010BA:  MOV     W0,AC
010BC:  BSET.B  81.7
010BE:  MOV     #1F08,W0
010C0:  MOV     W0,6A4
010C2:  MOV     #300,W0
010C4:  MOV     W0,6C8
010C6:  MOV     #46,W0
010C8:  MOV.B   W0L,742
010CA:  MOV     #57,W0
010CC:  MOV.B   W0L,742
010CE:  BSET.B  742.6
010D0:  MOV     #8000,W4
010D2:  MOV     W4,220
010D4:  MOV     #400,W4
010D6:  MOV     W4,222
010D8:  BSET.B  220.3
010DA:  MOV     #56,W4
010DC:  MOV     W4,228
010DE:  CLR     800
010E0:  CLR     802
010E2:  CLR     804
010E4:  CLR     806
010E6:  CLR     808
010E8:  CLR     80A
010EA:  CLR     80C
010EC:  CLR     80E
010EE:  CLR     810
010F0:  CLR     812
010F2:  CLR     814
010F4:  CLR     816
010F6:  CLR     818
010F8:  CLR     820
010FA:  MOV     #4254,W4
010FC:  MOV     W4,822
010FE:  CLR     830
01100:  CLR     832
01102:  CLR     834
01104:  MOV     #28,W4
01106:  MOV     W4,836
01108:  CLR     83A
0110A:  SETM    32C
0110C:  MOV     #3F80,W15
0110E:  MOV     #3FFF,W0
01110:  MOV     W0,20
01112:  NOP     
....................    inicializa_oscilador(); 
01114:  CALL    F74
....................     
....................    inicializa_perifericos_variaveis(); 
01118:  CALL    F96
....................     
....................    inicializa_interrupcao(); 
0111C:  CALL    109E
....................     
....................    printf("Teste"); 
01120:  MOV     #0,W1
01122:  MOV     W1,W0
01124:  CALL    200
01128:  INC     W1,W1
0112A:  MOV     W1,[W15++]
0112C:  BTSC.B  223.1
0112E:  BRA     112C
01130:  MOV     W0,224
01132:  MOV     [--W15],W1
01134:  MOV     #4,W0
01136:  CPSGT   W1,W0
01138:  BRA     1122
....................     
....................    while(true); 
0113A:  GOTO    113A
....................     
....................    /*CNI_isr(); //Primeira comutao do motor 
....................     
....................    while(i<1001); //Enquanto o vetor de velocidade no estiver cheio, espera 
....................    disable_interrupts(INTR_GLOBAL); //Depois de cheio, desliga interrupes 
....................    running_motor=0; //Desativa flag do motor girado 
....................     
....................    for(i=0; i<1001; i++) //Envia para a serial cada valor de velocidade obtido 
....................    { 
....................       printf("\n\r %f", vetor_velocidade[i]);       
....................    }*/ 
....................     
.................... } 
0113E:  PWRSAV  #0

Configuration Fuses:
   Word  1L: 00C7   NOWRTB NOBSS NORBS
          H: 0000  
   Word  2L: 00C7   NOWRTSS NOSSS NORSS
          H: 0000  
   Word  3L: 0007   NOWRTSS NOPROTECT
          H: 0000  
   Word  4L: 0083   PR_PLL IESO
          H: 0000  
   Word  5L: 0025   XT NOOSCIO IOL1WAY CKSFSM
          H: 0000  
   Word  6L: 005F   WPOSTS16 WPRES128 WINDIS NOWDT
          H: 0000  
   Word  7L: 00F7   PUT128 ALTI2C LPOL_HIGH HPOL_HIGH NOPWMPIN
          H: 0000  
   Word  8L: 00C3   ICSP1 NOJTAG NODEBUG
          H: 0000  
